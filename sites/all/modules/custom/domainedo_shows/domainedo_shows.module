<?php
/**
 * @file
 * Code for the Domaine d'O Spectacles feature.
 */

include_once 'domainedo_shows.features.inc';


/**
 * Implements hook_form_FORM_ID_alter().
 */
function domainedo_shows_form_show_node_form_alter(&$form, &$form_state, $form_id) {
	// Vertical tab "Lien distribution" moved to bottom of existing tabs in create/edit form.
  //$form['#groups']['group_casting']->weight = 1000;

  $form['#groups']['group_casting']->weight = 1000;
  /* A faire sur les champs url billetterie  mapado
  $form['#after_build'][] = 'crealead_newsflashes_after_build'; */
}
/* function crealead_newsflashes_after_build($form, &$form_state) {
  // Make the field field_sent readonly if user is not superadmin.
  global $user;

  if ($user->uid != 1) {
    $form['field_sent']['#attributes']['readonly'] = 'readonly';
  }
 return $form;
} */
/**
 * Implements hook_node_view_alter().
 */
function domainedo_shows_node_view_alter(&$build) {
  //dpm($build);

  // If show node
  // on recule la date de 4 h pour permettre aux internautes d'acheter alors que le
  // spectacle est en cours
  $now = date("Y-m-d\TH:i:sP", strtotime('-4 hours'));
  $now = new DateTime( $now );
  $now = $now->format('Ymd');

  $show_is_past = false;
  if ($build['#bundle'] == 'festival') {
    drupal_add_js(drupal_get_path('module', 'domainedo_shows') .'/domainedo_shows_manageTwoColsFestival.js');
    drupal_add_js(drupal_get_path('module', 'domainedo_shows') .'/domainedo_shows_empty_fields.js');
  }
	if ($build['#bundle'] == 'show') {
    if ($build['#view_mode'] == 'teaser') {
      // Récupération du lieu parent pour déterminer si le spectacle
      // est hors les murs
      drupal_add_js(drupal_get_path('module', 'domainedo_shows') .'/domainedo_date_show_list_festival.js');
      $tid = $build['body']['#object']->field_location['und'][0]['tid'];
      $parent = taxonomy_get_parents($tid);
      $is_extra = false;
      foreach ($parent as $key => $value){
        if(stristr( $parent[$key]->name, "intra")) {
          $is_extra = false;
        } else $is_extra = true;
      }
      if($is_extra) {
        $build['field_scald_image'][0]['#markup'] .=
        '<div title="Hors les murs du domaine d\'O" class="extramuros">'.
        '  <span class="sr-only">Hors les murs</span>'.
        '</div>';
      }

    }
		// Processing of festival's name in List view mode.
		if ($build['#view_mode'] == 'list' && isset($build['field_festival'][0]['#markup'])) {
			$festival_infos = domainedo_shows_get_festival_infos($build['field_festival'][0]['#markup'], array('title'));
			if (!empty($festival_infos)) {
				$build['field_festival'][0]['#markup'] = $festival_infos['title'];
			}
			else {
				unset($build['field_festival']);
			}
		}
		if ($build['#view_mode'] == 'liste_aussi') {
      $show_is_past = false;
      for ($i = 0; $i < count($build['field_show_dates']['#items']); $i++) {
          $show_date_item = $build['field_show_dates']['#items'][$i]['value'];
          $show_date_item = substr($show_date_item, 0, 10);
          $show_date_item = new DateTime( $show_date_item );
          $show_date_item = $show_date_item->format('Ymd');

          if ($now <= $show_date_item) {
            $show_is_past  = false;
            break;
          } else {
            $show_is_past = true;
          }
        }
        if ($show_is_past) $build = null;

    }
		if ($build['#view_mode'] == 'full') {
      // Structured datas
      $array_structured_data = array();



      /* Attention : S'il s'agit de plusieurs spectacles répartis sur plusieurs
      jours et nécessitant chacun un billet d'entrée individuel, ajoutez un
      élément Event distinct pour chaque spectacle.
      cf : https://developers.google.com/search/docs/data-types/event */
      if(isset($build['body']['#object']->field_show_dates['und'])) {
        foreach($build['body']['#object']->field_show_dates['und'] as $key => $date) {
          $structured_data = array(
            '@context' => 'http://schema.org',
            '@type' => 'Event',
          );
          // Titre
          $structured_data['name'] = $build['body']['#object']->title;

          // Gestion des dates
          $structured_data['startDate'] = $date['value'];

          // Adresse
          $location_tid = $build['body']['#object']->field_location['und'][0]['tid'];
          $location = taxonomy_term_load($location_tid)->name;
          $parents = taxonomy_get_parents($location_tid);
          $parent = reset($parents)->name;

          // Gestion des lieux
          if (strtoupper($parent) == 'INTRAMUROS') {
            $structured_data['location'] = array(
              "@type" => "Place",
              "name"=> "Domaine d'O > " . $location,
              "address"=> array(
                "@type" => "PostalAddress",
                "@streetAddress" => "178, rue de la Carriérasse",
                "@addressLocality" => "Montpellier",
                "@postalCode" => "34090")
            );
          } else {
            $show_address = explode(' - ', $location);
            $city = $show_address[0];
            $place = $show_address[1];
            $structured_data['location'] = array(
              "@type" => "Place",
              "name"=> $place ,
              "address"=> array(
                "@type" => "PostalAddress",
                "@addressLocality" => $city)
            );
          }

          // Image
          if (isset($build['body']['#object']->field_scald_image['und'][0]['sid'])) {
            $atom = scald_atom_load($build['body']['#object']->field_scald_image['und'][0]['sid']);
            $image_url = file_create_url($atom->file_source);
            $image_url_exploded = explode("default/files/", $image_url);
            // choix arbitraire du style d'image zoom_ss_634x440
            $image_url =
              $image_url_exploded[0] .
              "default/files/styles/zoom_ss_634x440/public/" .
              $image_url_exploded[1];

            $structured_data['image'] = $image_url;
          }

          // Performer
          if (isset($build['body']['#object']->field_by['und'][0]['target_id'])) {
            $structure_titles = array();
            $structure_type = "";
            $has_structure_organization = false;
            foreach($build['body']['#object']->field_by['und'] as $structure) {
              $structure = node_load($structure['target_id']);
              $structure_titles[] = $structure->title;

              $structure_type = taxonomy_term_load($structure->field_structure_type['und'][0]['tid'])->name;
              // il suffit qu'une seule structure ne soit pas un "artiste" seul pour
              // que l'on considère que c'est une "organisation" au sens de https://schema.org/Event
              if($structure_type != "Artiste seul") $has_structure_organization = true;
            }
            $structure_type = ($has_structure_organization) ? "Organization" : "Person";
            $structure_titles_string = implode(' / ', $structure_titles);

            $structured_data['performer'] = array(
              "@type" => $structure_type,
              "name"=> $structure_titles_string
            );
          }

          // Offers
          if (isset($build['body']['#object']->field_price['und'][0]['value'])) {
            $price = $build['body']['#object']->field_price['und'][0]['value'];
            $structured_data['offers'] = array(
              "@type" => "Offer",
              "price" => $price
            );
          }

          // on ajoute un spectacle au tableau $array_structured_data
          array_push($array_structured_data,$structured_data);
        }
        if(count($build['body']['#object']->field_show_dates['und']) == 1){
          $array_structured_data = $array_structured_data[0];
        }
        // Encodage json de la totalité des infos *****/
        $json_ld_script = array(
            '#tag' => 'script',
            '#attributes' => array('type' => 'application/ld+json'),
            '#value' => defined('JSON_UNESCAPED_SLASHES') ?
            json_encode($array_structured_data, JSON_UNESCAPED_SLASHES) :
            json_encode($array_structured_data),
            //'#value' => 'console.log("Hello structured data");',
        );
        drupal_add_html_head($json_ld_script, 'structured_data_json_ld');
      }
      /* End of structured data ***********************************************/

      drupal_add_js(drupal_get_path('module', 'domainedo_shows') .'/domainedo_shows.js');
      drupal_add_js(drupal_get_path('module', 'domainedo_shows') .'/domainedo_date_show.js');

      //dpm($build);
      /* Teste s'il y a bien un formulaire joint et appelle le script js le cas échéant */
      if(!empty($build['body']['#object']->field_formulaire)) {
        drupal_add_js(drupal_get_path('module', 'domainedo_shows') .'/domainedo_form.js');
      }
      // Breadcrumb processing : if the show node is requested from a festival page,
			// the breadcrumb link 'Tous les spectacles' must send user to the shows list
			// filtered on the latest edition of the same festival.
			$url_elements = explode('/', $_SERVER['HTTP_REFERER']);
			// If the fourth element of the referer url contains a festival name, then we come from a festival page.
			if (isset($url_elements[4]) && in_array($url_elements[4], array_keys(domainedo_shows_get_festivals()))) {
				$festival_values = domainedo_shows_get_latest_festival_values($url_elements[4]);
				$latest_festival_id = $festival_values['nid'];
				$breadcrumb = drupal_get_breadcrumb();
				$modified_url = url('spectacles/tous-les-spectacles', array('query' => array('field_festival_target_id' => $latest_festival_id)));
				$modified_link = '<a href="' . $modified_url . '">Tous les spectacles</a>';
				$breadcrumb[2] = $modified_link;
				drupal_set_breadcrumb($breadcrumb);
			}

			//Puts a link on Festival name, except for festival-hiver.
			if (isset($build['field_festival'])) {
				$festival_infos = domainedo_shows_get_festival_infos($build['field_festival']['#items'][0]['target_id'], array('title', 'url'));
				if (!empty($festival_infos)) {
					$build['field_festival'][0]['#markup'] = '<a href="/' . $festival_infos['url'] . '">' . $build['field_festival'][0]['#markup'] . '</a>';
				}
			}

			// Manage display of fields depending on Reservation value : prochainement=1, url billetterie=2, complet=3, annulé=4)
			$field_reservation_value = $build['field_reservation']['#items'][0]['value'];

      /* In the case where the link to ticketing is enable and the show went,
       * we automaticly enable the "passed" option : $field_reservation_value = 5;
      */


      $show_has_ticket_link = (isset($build['field_reservation']) && $build['field_reservation']['#items'][0]['value'] == 2);
      $show_is_past = false;
      if ($show_has_ticket_link && isset($build['field_show_dates']['#items'])){
        for ($i = 0; $i < count($build['field_show_dates']['#items']); $i++) {
          $show_date_item = $build['field_show_dates']['#items'][$i]['value'];
          $show_date_item = substr($show_date_item, 0, 10);
          $show_date_item = new DateTime( $show_date_item );

          $show_date_item = $show_date_item->format('Ymd');

          if ($now <= $show_date_item) {
            $show_is_past  = false;
            break;
          } else {
            $show_is_past = true;
          }
        }

      }
      if ($show_is_past) $field_reservation_value = 5;
			$dependent_fields = array(
					'1' => 'field_coming_soon',
					'2' => 'field_boxoffice_url',
					'3' => 'field_full',
					'4' => 'field_reimbursement',
					'6' => 'field_offline',
			);
			foreach ($dependent_fields as $key=>$field_name) {
				if ($key != $field_reservation_value) {
					unset($build[$field_name]);
				}
			}

			// Manage display of link Distribution
			if (!isset($build['field_casting'])) {
				unset($build['field_casting_link']);
			}

			// Processing of field Reservation when its value is 'annulé'.
			if (isset($build['field_reservation']) && $build['field_reservation']['#items'][0]['value'] == 4) {
				$start_tag = '';
				$end_tag = '';
				if ($build['#view_mode'] == 'full') {
					$start_tag = '<h3>';
					$end_tag = '</h3>';
				}
				if ($build['#view_mode'] == 'list') {
					$start_tag = '<h4>';
					$end_tag = '</h4>';
				}
				$build['field_reservation'][0]['#markup'] = $start_tag . $build['field_reservation'][0]['#markup'] . $end_tag;
			}

			// Displays video, sound and photos links only if corresponding fields contain data.
			if (!isset($build['field_scald_video'])) {
				unset($build['field_video_link']);
			}
			if (!isset($build['field_scald_sound'])) {
				unset($build['field_sound_link']);
			}
			if (!isset($build['field_scald_gallery'])) {
				unset($build['field_photos_link']);
			}
		}
	}
}

/**
 * Returns the list of managed festivals.
 *
 * @return array Festivals.
 */
function domainedo_shows_get_festivals() {
	$festivals = array(
			'saperlipopette' => array('title' => 'Saperlipopette', 'weight' => 11, 'url' => 'spectacles/saperlipopette'),
			'printemps-des-comediens' => array('title' => 'Printemps des comédiens', 'weight' => 12, 'url' => 'spectacles/printemps-des-comédiens'),
			'folies-do' => array('title' => 'Folies d\'O', 'weight' => 13, 'url' => 'spectacles/folies-do'),
			'radio-france' => array('title' => 'Radio France', 'weight' => 14, 'url' => 'spectacles/radio-france'),
			'nuits-do' => array('title' => 'Nuits d\'O', 'weight' => 15, 'url' => 'spectacles/nuits-do'),
			'arabesques' => array('title' => 'Arabesques', 'weight' => 16, 'url' => 'spectacles/arabesques'),
			'festival-hiver' => array('title' => 'Festival d\'hiver', 'weight' => 17, 'url' => 'spectacles/festival-dhiver'),
      'nuit-gitane' => array('title' => 'Nuit Gitane', 'weight' => 18, 'url' => 'spectacles/nuit-gitane'),
      'cine-metropole' => array('title' => 'Ciné Métropole', 'weight' => 19, 'url' => 'spectacles/cine-metropole'),
      'cirque-metropole' => array('title' => 'Cirque Métropole', 'weight' => 20, 'url' => 'spectacles/cirque-metropole'),
	);

	return $festivals;
}

/**
 * Returns the Festival name of a given edition
 *
 * @param int Nid of the Festival edition.
 * @param array An array containing the requested info types.
 * @return array Array containing requested festival info values.
 */
function domainedo_shows_get_festival_infos($edition_id, $info_types) {
	$query = db_select('node', 'n');
	$query->join('field_data_field_festival_name', 'f', 'n.nid = f.entity_id');

	$query->addField('f', 'field_festival_name_value', 'name');
	$query->condition('n.nid', $edition_id);

	$result = $query->execute()->fetchField();//

	if ($result != 'festival-hiver') {
		$festivals = domainedo_shows_get_festivals();
		$info_values = array('title' => '', 'url' => '');
		foreach ($info_types as $type) {
			$info_values[$type] = $festivals[$result][$type];
		}
		return $info_values;
	}
	return null;
}

/**
 * Returns the latest festival (latest season) of a given festival name.
 *
 * @param string $festival_name The name of the festival.
 * @param int $ignored_id Nid of the festival edition to be ignored.
 * @return int Nid of the latest festival.
 */
function domainedo_shows_get_latest_festival_values($festival_name, $ignored_id=FALSE) {
	$query = db_select('node', 'n');
	$query->join('field_data_field_festival_name', 'f', 'n.nid = f.entity_id');
	$query->join('field_data_field_season', 's', 'n.nid = s.entity_id');

	$query->addField('n', 'nid');
	$query->addField('f', 'field_festival_name_value', 'name');
	$query->addField('s', 'field_season_value', 'season');
	$query->condition('n.type', 'festival')
	->condition('f.field_festival_name_value', $festival_name)
	->condition('n.status', '1');

	$result = $query->execute()->fetchAll();

	$festival_values = array();
	foreach ($result as $festival) {
		if ($ignored_id && $festival->nid == $ignored_id) continue;
		$festival_values[$festival->season] = $festival->nid;
	}
	krsort($festival_values);
	return array('nid' => current($festival_values), 'season' => key($festival_values));
}

/**
 * Implements hook_node_validate().
 */
function domainedo_shows_node_validate($node, $form, &$form_state) {
	if ($node->type == 'festival') {
		// If we are trying to save a new node
		if (!$form_state['values']['nid']) {
			$query = new EntityFieldQuery();
			$query->entityCondition('entity_type', 'node')
			->entityCondition('bundle', 'festival')
			->fieldCondition('field_season', 'value', $form_state['values']['field_season']['und'][0]['value'])
			->fieldCondition('field_festival_name', 'value', $form_state['values']['field_festival_name']['und'][0]['value'])
			->count();

			$count = $query->execute();
			// and the same festival already exists
			if ($count > 0) {
				form_set_error('festival_unique', t('This festival edition already exists.'));
			}
		}
	}
}

/**
 * Implements hook_node_presave().
 */
function domainedo_shows_node_presave($node) {
	// If node is festival, we must manage menu links.
	if ($node->type == 'festival') {
		///////////////// 1st SITUATION - INSERTION OF A NEW FESTIVAL ////////////////////////////////
		if ($node->is_new) {
			// If the festival is the latest one,
			if ($previous_festival_values = is_latest_festival($node)) {
				// a new menu link is prepared,
				$festivals = domainedo_shows_get_festivals();
				$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_title = :title", array(  ':title' => 'Spectacles',))->fetchField();
				$node->menu['link_title'] = $festivals[$node->field_festival_name['und'][0]['value']]['title'];
				$node->menu['plid'] = $mlid;
				$node->menu['weight'] = $festivals[$node->field_festival_name['und'][0]['value']]['weight'];
				$node->menu['parent'] = 'parent:' . $mlid;;
				$node->menu['enabled'] = 1;
				$node->menu['description'] = '';

				// If a previous festival exists,
				if(!is_bool($previous_festival_values)) {
					list($previous_festival_nid, $previous_festival_season) = $previous_festival_values;
					// its menu link is deleted
					$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_path = :path", array(  ':path' => 'node/' . $previous_festival_nid,))->fetchField();
					menu_link_delete($mlid);

					// and its path alias is changed from "spectacles/festival-name" to "spectacles/festival-name/season-value".
					$festival_data = array_merge($previous_festival_values, array($node->field_festival_name['und'][0]['value']));
					domainedo_shows_festival_pathalias_update($festival_data);
				}
			}
			// If it's not the latest one,
			else {
				// No menu link to build, but its path alias must be "spectacles/festival-name/season-value".
				$node->path['alias'] = 'spectacles/' . $node->field_festival_name['und'][0]['value'] . '/' . $node->field_season['und'][0]['value'];
				// and we must deactivate the pathauto mechanism,
				// otherwise it will replace the $node->path['alias'] we've just built
				// by its own value, that is with no trailing season value.
				$node->path['pathauto'] = 0;
			}
		}
		////////////////////// 2nd SITUATION - UPDATE OF AN EXISTING FESTIVAL ////////////////////////////
		else {
			// Two data have to be figured out :
			// - the menu link
			// - the path alias
			// We must act only if festival name and/or season value have been altered, so let's test it first.
			$is_festival_name_modified = FALSE;
			$is_season_modified = FALSE;

			if ($node->field_season['und'][0]['value'] != $node->original->field_season['und'][0]['value']) {
				$is_season_modified = TRUE;
			}
			if ($node->field_festival_name['und'][0]['value'] != $node->original->field_festival_name['und'][0]['value']) {
				$is_festival_name_modified = TRUE;
			}

			// If festival name and/or season value have been altered, we must act !
			if ($is_festival_name_modified || $is_season_modified) {
				// If the festival being updated IS THE LATEST ONE,
				if ($previous_festival_values = is_latest_festival($node, FALSE)) {
					// its menu link must be built (or rebuilt).
					// So, the existing menu link, if any, is deleted
					$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_path = :path", array(  ':path' => 'node/' . $node->nid,))->fetchField();
					if ($mlid) {
						menu_link_delete($mlid);
					}
					else {
						dsm('pas de lien de menu à supprimer');
					}
					// a new menu link is prepared
					$festivals = domainedo_shows_get_festivals();
					$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_title = :title", array(  ':title' => 'Spectacles',))->fetchField();
					$node->menu['link_title'] = $festivals[$node->field_festival_name['und'][0]['value']]['title'];
					$node->menu['plid'] = $mlid;
					$node->menu['weight'] = $festivals[$node->field_festival_name['und'][0]['value']]['weight'];
					$node->menu['parent'] = 'parent:' . $mlid;;
					$node->menu['enabled'] = 1;
					$node->menu['description'] = '';

					// and its path alias must be updated to "spectacles/festival-name".
					$node->path['pathauto'] = 0;
					$node->path['alias'] = 'spectacles/' . $node->field_festival_name['und'][0]['value'];

					// If season value has changed, that means that the previous festival was the latest one before current update.
					// Note : if there is only one festival in the current category (festival name),
					// the function is_latest_festival() returns the boolean TRUE instead of an array of values.
					// In that case, nothing to do. So we must test it as well.
					if ($is_season_modified && !is_bool($previous_festival_values)) {
						list($previous_festival_id, $previous_festival_season) = $previous_festival_values;
						// The previous festival's menu link must be deleted
						$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_path = :path", array(  ':path' => 'node/' . $previous_festival_id,))->fetchField();

						// and its path alias must be "spectacles/festival-name/season-value".
						$previous_festival_values = array_merge($previous_festival_values, array($node->field_festival_name['und'][0]['value']));
						domainedo_shows_festival_pathalias_update($previous_festival_values);
					}
				}
				// If it's NOT THE LATEST ONE
				else {
					// the existing menu link, if any, is deleted
					$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_path = :path", array(  ':path' => 'node/' . $node->nid,))->fetchField();
					if ($mlid) {
						menu_link_delete($mlid);
					}
					else {
						dsm('no menu link to delete');
					}
					// and the path alias must be "spectacles/festival-name/season-value".
					$node->path['pathauto'] = 0;
					$node->path['alias'] = 'spectacles/' . $node->field_festival_name['und'][0]['value'] . '/' . $node->field_season['und'][0]['value'];

					// If season value of the festival being updated has changed
					if ($is_season_modified) {
						// and if this festival was the latest one before current update,
						if ($original_previous_festival_values = is_latest_festival($node->original, FALSE)) {
							// The original previous festival will be the latest one after current update.
							// So, we give it a menu link
							$festivals = domainedo_shows_get_festivals();
							$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_title = :title", array(  ':title' => 'Spectacles',))->fetchField();
							$item = array(
								'link_title' => $festivals[$node->field_festival_name['und'][0]['value']]['title'],
								'link_path' => 'node/' . $original_previous_festival_values[0],
								'menu_name' => 'main-menu:' . $mlid,
								'plid' => $mlid,
								'weight' => $festivals[$node->field_festival_name['und'][0]['value']]['weight'],
							);
							menu_link_save($item);

							// and we alter its path alias to "spectacles/festival-name".
							$original_previous_festival_values = array_merge($original_previous_festival_values, array($node->field_festival_name['und'][0]['value']));
							domainedo_shows_festival_pathalias_update($original_previous_festival_values, TRUE);
						}
					}
				}
			}
		}
	}
  if ($node->type == 'show') {
    $node->body['und'][0]['value'] = str_replace("&nbsp;", " ", $node->body['und'][0]['value']);
  }
}

/**
 * Tests if a processed festival ($node) is the more recent one.
 * If yes, returns nid of the previous season's festival, or TRUE if there is no previous festival.
 * If no, return FALSE.
 *
 * @param Object $node The tested festival.
 * @param Bolean $is_new TRUE is the processed festival is new, otherwise FASLE.
 * @return mixed
 * 	 A boolean TRUE if the processed festival is the latest one and no previous festival exists.
 *   A array ($nid, $season) nid and season values of the previous festival, if any and if the processed festival is the latest one.
 *   A boolean FALSE if the processed festival is not the latest one.
 */
function is_latest_festival($node, $is_new=TRUE) {
	// First, seeks all the registered festivals whose name is $festival_name
	$query = db_select('node', 'n');
	$query->join('field_data_field_festival_name', 'f', 'n.nid = f.entity_id');
	$query->join('field_data_field_season', 's', 'n.nid = s.entity_id');

	$query->addField('n', 'nid');
	$query->addField('s', 'field_season_value', 'season');
	$query->condition('n.type', 'festival')
	->condition('f.field_festival_name_value', $node->field_festival_name['und'][0]['value']);
	//->condition('n.status', '1');

	// If current process is an update or deletion, the festival node being performed
	// must NOT be retrieved from database to prevent to be compared to itself.
	if(!$is_new) {
		//$query->condition('s.field_season_value', $node->field_season['und'][0]['value'], '<>');
		$query->condition('n.nid', $node->nid, '<>');
	}

	$result = $query->execute()->fetchAll();

	// If there is no previous festival registered
	if (empty($result)){
		return TRUE;
	}

	// else gets the season and nid values of the latest registered festival
	$max_season = 0;
	$previous_nid = 0;
	foreach($result as $festival) {
		if ($festival->season > $max_season) {
			$max_season = $festival->season;
			$previous_nid = $festival->nid;
		}
	}

	// Finally, compares theses values to the festival in registration process
	$season_to_save = $node->field_season['und'][0]['value'];
	// If this festival is latest
	if ($season_to_save > $max_season) {
		return array($previous_nid, $max_season);
	}
	// else
	else {
		return FALSE;
	}
}

/**
 * Updates the path alias of a given festival when it is no longer the latest one.
 * Results in adding season value to the end of the existing alias.
 *
 * @param array $values An array containing the previous festival's nid, season and name values;
 */
function domainedo_shows_festival_pathalias_update($values, $is_latest=FALSE) {
	list($festival_nid, $festival_season, $festival_name) = $values;
	// Delete first the existing path alias
	$old_path = path_load('node/' . $festival_nid);
	path_delete($old_path['pid']);
	// and then save the new one.
	$alias = 'spectacles/' . $festival_name;
	if (!$is_latest) {
		$alias = $alias . '/' . $festival_season;
	}
	$path = array(
			'source' => 'node/' . $festival_nid,
			'alias' => $alias,
	);
	path_save($path);
}

/**
 * Implements hook_node_delete().
 */
function domainedo_shows_node_delete($node) {
	if ($node->type == 'festival') {
		// If latest
		if ($previous_festival_values = is_latest_festival($node, FALSE)) {
			// and if a previous festival exists,
			if(!is_bool($previous_festival_values)) {
				// a menu link is created for this festival
				$festivals = domainedo_shows_get_festivals();
				$mlid = db_query("SELECT mlid FROM {menu_links} WHERE link_title = :title", array(  ':title' => 'Spectacles',))->fetchField();
				$item = array(
					'link_title' => $festivals[$node->field_festival_name['und'][0]['value']]['title'],
					'link_path' => 'node/' . $previous_festival_values[0],
					'menu_name' => 'main-menu:' . $mlid,
					'plid' => $mlid,
					'weight' => $festivals[$node->field_festival_name['und'][0]['value']]['weight'],
				);
				menu_link_save($item);

				// and its path alias is updated.
				$festival_values = array_merge($previous_festival_values, array($node->field_festival_name['und'][0]['value']));
				domainedo_shows_festival_pathalias_update($festival_values, TRUE);
			}
		}
	}
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function domainedo_shows_form_festival_node_form_alter(&$form, &$form_state, $form_id) {
	// Move to bottom the vertical tab containing the domaine d'O technical fields.
	// Hey ! Give me a break ! I know there is a typo on 'fiels' (instead of 'fields')
	// but I'm too lazy to delete and recreate the corresponding custom field group in festival content type.
	$form['#groups']['group_technical_fiels']->weight = 1000;

	// In edit form only, disables the festival_name field to prevent user to change it.
	if (isset($form_state['node']->nid)) {
		$form['field_festival_name']['#disabled'] = TRUE;
	}
}

/**
 * Implements hook_views_pre_render().
 */
function domainedo_shows_views_pre_render(&$view) {
  if ($view->name == 'calendar' && $view->current_display == 'page_1') {
    drupal_add_js(drupal_get_path('module', 'domainedo_shows') .'/domainedo_shows_calendar.js');
  }
	/*if ($view->name == 'shows' && $view->current_display == 'list') {
		$block = module_invoke('views', 'block_view', '-exp-shows-list');
		$view->header['area']->options['content'] = render($block['content']);
	}*/
	if ($view->name == 'shows' && $view->current_display == 'views_data_export_1') {
		foreach ($view->result as &$value) {
			$array = array();
			preg_match( '/src="([^"]*)"/i', $value->field_field_scald_image[0]['rendered']['#markup'], $array );
			if (isset($array[1])) $value->field_field_scald_image[0]['rendered']['#markup'] = $array[1];
		}
	}
	if ($view->name == 'shows' && ($view->current_display == 'block_1' || $view->current_display == 'list')) {
    drupal_add_js(drupal_get_path('module', 'domainedo_shows') .'/domainedo_date_show_list.js');
	}
  if ($view->name == 'shows' && $view->current_display == 'list') {
    /**
     * Fait appel à l'affichage de la fenêtre modal qui n'existe que dans le cas
     * où il n'y a pas de résultat à la requêtes de spectacles sur un festival passé
    */
    // Re
    drupal_add_js(drupal_get_path('module', 'domainedo_shows') .'/domainedo_shows_festival_modal.js');
  }

 /* dpm($view->name);
  dpm($view->current_display);*/
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function domainedo_shows_form_views_exposed_form_alter(&$form, &$form_state, $form_id) {
       if (isset($form['field_festival_target_id'])) {
               // Get the id of the latest festival for each festival type.
               $festivals = domainedo_shows_get_festivals();
               $latest_festival_ids = array();
               foreach ($festivals as $name=>$festival) {
                       $latest_festival = domainedo_shows_get_latest_festival_values($name);
                       if ($latest_festival['nid'] != 0) {
                               $latest_festival_ids[$latest_festival['nid']] = $latest_festival['nid'];
                       }
               }

               // Compare the exposed festival list and the latest festival list
               // to get rid of festivals not being the latest.
               foreach ($form['field_festival_target_id']['#options'] as $key=>$label) {
                       if (!is_numeric($key)) continue;
                       if (!in_array($key, $latest_festival_ids)) {
                               unset($form['field_festival_target_id']['#options'][$key]);
                       }
               }

               $form['field_festival_target_id']['#options']['All'] = t('All upcoming shows');
       }
}

/**
 * Implements hook_menu_block_blocks().
 * Used to export blocks generated by menu_block module (see menu_block_export module).
 */
function domainedo_shows_menu_block_blocks() {
	// $parent_mlid values are different on different Drupal instances (dev, preprod, prod).
	// So we must fetch this value from the database, based on menu link Title (Spectacles in this case).
	$parent_mlid = db_select('menu_links', 'ml')->fields('ml', array('mlid'))->condition('link_title', 'Spectacles')->execute()->fetchField();

	return array(
		'domainedo-shows-tab-menu' => array(
				'menu_name'   => 'main-menu',
				'parent_mlid' => $parent_mlid,
				'title_link'  => 0,
				'admin_title' => 'Menu Spectacles à onglets',
				'level'       => 1,
				'follow'      => 0,
				'depth'       => 0,
				'expanded'    => 0,
				'sort'        => 0,
		),
	);
}
function textFestival($festival_name, $festival_season) {
  if(strpos($festival_name, 'hiver') !== false ) {
    $season_first_year = substr($festival_season, -2);
    $season_second_year = $season_first_year + 1;
    return " de la Saison ". $season_first_year. "/" .$season_second_year;
  } else if(strpos($festival_name, 'cirque') !== false ) {
    return " de la Métropole fait son Cirque";
  } else if(strpos($festival_name, 'cine') !== false ) {
    return " de la Métropole fait son Cinéma";
  } else if(strpos($festival_name, 'nuits') !== false ) {
    return " des Nuits d'O";
  } else if(strpos($festival_name, 'arabesques') !== false ) {
    return " d'Arabesques";
  } else if(strpos($festival_name, 'radio') !== false ) {
    return " de Radio France";
  } else if(strpos($festival_name, 'saperlipopette') !== false ) {
    return " de Saperlipopette";
  } else if(strpos($festival_name, 'printemps') !== false ) {
    return " du Printemps des Comédiens";
  } else if(strpos($festival_name, 'folies') !== false ) {
    return " des Folies d'O";
  }
}
/**
 * Implements hook_node_postsave().
 * Le principe est de placer dans le champ "field_no_result"
 * Le message qui s'affichera après un click sur le festival sur la page "/spectacles/tous-les-spectacles"
 * lorsqu'il n'y a plus de spectacles en cours grâce au mécanisme suivant :
 * la vue qui affiche tous les spectacles (admin/structure/views/view/shows/edit/list)
 * affiche (en cas de non résultat) via le champ NO RESULTS BEHAVIOR une vue de festival :
 * admin/structure/views/view/festivals. Cette dernière a un filtre contextuel capable
 * de comprendre quel est est le festival concerné grâce à l'url qui indique le nid du
 * festival. Cette vue ne sélectionne que le champ field_no_result...
 * Par ailleurs si le festival n'a pas de spectacles (passés ou pas), on considère que
 * c'est parce qu'il n'est pas encore programmé. On affichera dans la fenêtre modal un lien
 * vers le festival tout en indiquant qu'il n'est pas encore programmé...
 */
function domainedo_shows_node_postsave($node, $op) {
  if ($node->type == 'festival') {
    $wrapper = entity_metadata_wrapper('node', $node);

    // nb de spectacles liés à ce festival
    $nb = count($node->field_festival_shows['und']);
    //watchdog('domainedo_shows', 'festival a  ' . $nb . ' spectacles');

    $festival_name =  $wrapper->field_festival_name->value();
    $festival_season = $wrapper->field_season->value();
    $next_season = $festival_season + 1;
    if ($festival_name == "festival-hiver") {
      $festival_name = "festival-dhiver";
      $season_first_year = substr($festival_season, -2);
      $season_second_year = $season_first_year + 1;
      $next_season = $season_second_year. "/" . ($season_second_year + 1);
    }
    $entities_reference_published = false;
    // Récupériation des entity references
    if($nb) {
      // teste si les spectacles référencés sont publiés
      if (isset($wrapper->{"field_festival_shows"})) {
        $target_ids = $wrapper->{"field_festival_shows"}->value();
        //dpm($target_ids);
        foreach($target_ids as $key => $value) {
          if($value->status) {
            $entities_reference_published = true;
            break;
          }
        }
      }
    }
    $no_result_msg = "";
    // Cas où le festival a des spectacles publiés
    if($entities_reference_published) {
      $no_result_msg =
      '<p class="field-no-result" data="with-show">' .
      '<a class="more-info-festival" href="/spectacles/' . $festival_name .
      '"><strong>L\'éditon ' . $festival_season . textFestival($festival_name, $festival_season) . '</a>' .
      ' est passée</strong>, rendez-vous prochainement pour l\'édition ' . $next_season .'.<br>
        Soyez les premiers à être informés : <strong>Inscrivez vous à la ' .
        '<a class="link-nl" href="/content/abonnement-la-lettre-dinformation-du-domaine-do">lettre d\'info</a>
        ou aux notifications</strong> du domaine d\'O.
        </p>'."\n".
      '<div class="modal fade" id="myModal" role="dialog">'."\n" .
      '<div class="modal-dialog">'."\n" .
      ' <div class="modal-content">'."\n" .
      '<div class="modal-header"><button class="close" data-dismiss="modal" type="button">×</button>'."\n" .
      '<h4 class="modal-title"></h4>'."\n" .

      '<div class="modal-body modal-no-result">'."\n" .
      '<p class="field-no-result">'.
      '<a class="more-info-festival" href="/spectacles/' . $festival_name .
      '"><strong>L\'éditon ' . $festival_season . textFestival($festival_name, $festival_season) . '</a>' .
      ' est passée</strong>, rendez-vous prochainement pour l\'édition ' . $next_season .'.<br>
        Soyez les premiers à être informés : <strong>Inscrivez vous à la ' .
        '<a class="link-nl" href="/content/abonnement-la-lettre-dinformation-du-domaine-do">lettre d\'info</a>
        ou aux notifications</strong> du domaine d\'O
        </p>'."\n" .
      '</div>'."\n" .
      '<div class="modal-footer"><button class="btn btn-default" data-dismiss="modal" type="button">Fermer</button></div>'."\n" .
      '</div>'."\n" .
      '</div>'."\n" .
      '</div>'."\n";


      // si on change de type de message dans le champ field_no_result
      // on sauvegarde
      if (!strpos($wrapper->field_no_result->value->raw() ,'with-show')) {
        $wrapper->field_no_result->value = $no_result_msg;
        watchdog('domainedo_shows', 'Node show avec spectacle publié ' . $node->nid . ' updated');
        $wrapper->save();
      } else watchdog('domainedo_shows', 'Node show avec spectacle publié' . $node->nid . 'not updated');

    } else { // cas où le festival n'a pas de spectacles ou qu'ils ne sont pas encore publiés
      $no_result_msg =
      '<p class="field-no-result" data="no-show">' .
      '<a class="more-info-festival" href="/spectacles/' . $festival_name .
      '"><strong>L\'éditon ' . $festival_season . textFestival($festival_name, $festival_season) . '</a>' .
      ' n\'est pas encore programmée</strong>.<br>
        Soyez les premiers à être informés : <strong>Inscrivez vous à la ' .
        '<a class="link-nSaperlipopettel" href="/content/abonnement-la-lettre-dinformation-du-domaine-do">lettre d\'info</a>
        ou aux notifications</strong> du domaine d\'O.
        </p>'."\n".
      '<div class="modal fade" id="myModal" role="dialog">'."\n" .
      '<div class="modal-dialog">'."\n" .
      ' <div class="modal-content">'."\n" .
      '<div class="modal-header"><button class="close" data-dismiss="modal" type="button">×</button>'."\n" .
      '<h4 class="modal-title"></h4>'."\n" .

      '<div class="modal-body modal-no-result">'."\n" .
      '<p class="field-no-result">'.
      '<a class="more-info-festival" href="/spectacles/' . $festival_name .
      '"><strong>L\'éditon ' . $festival_season . textFestival($festival_name, $festival_season) . '</a>' .
      ' n\'est pas encore programmée</strong>, <br>
        Soyez les premiers à être informés : <strong>Inscrivez vous à la ' .
        '<a class="link-nl" href="/content/abonnement-la-lettre-dinformation-du-domaine-do">lettre d\'info</a>
        ou aux notifications</strong> du domaine d\'O
        </p>'."\n" .
      '</div>'."\n" .
      '<div class="modal-footer"><button class="btn btn-default" data-dismiss="modal" type="button">Fermer</button></div>'."\n" .
      '</div>'."\n" .
      '</div>'."\n" .
      '</div>'."\n";

      // si on change de type de message dans le champ field_no_result
      // on sauvegarde
      if (!strpos($wrapper->field_no_result->value->raw() ,'no-show')) {
        $wrapper->field_no_result->value = $no_result_msg;
        watchdog('domainedo_shows', 'Node show sans spectacle ' . $node->nid . ' updated');
        $wrapper->save();
      } else watchdog('domainedo_shows', 'Node show sans spectacle ' . $node->nid . ' not updated');
    }

  }
}
function getFestival($node_show) {
  $wrapper = entity_metadata_wrapper('node', $node_show);
  $festival_id = 0;
  $festival = NULL;
  if (isset($wrapper->{"field_festival"})) {
      $target_ids = $wrapper->{"field_festival"}->value();
      //dpm($target_ids);
      foreach($target_ids as $key => $value) {
        $festival_id = $value;
        break;
      }
  }
  if($festival_id) {
    $festival = node_load($festival_id);
    return $festival;
  } else return NULL;
}

/**
 * Implements hook_node_update().
 *
 */
function domainedo_shows_node_update($node) {
  if ($node->type == 'show') {
    // Si Dépublication
    if ($node->original->status == 1 && $node->status == 0) {

      $festival = getFestival($node);
      if($festival) {
        $entities_reference_published = false;
        $wrapper = entity_metadata_wrapper('node', $festival);
        watchdog('domainedo_shows', 'Node show dé-publié ' . $festival->title);
        // teste si les spectacles référencés sont publiés
        if (isset($wrapper->{"field_festival"})) {
          $target_ids = $wrapper->{"field_festival"}->value();
          //dpm($target_ids);
          foreach($target_ids as $key => $value) {
            if($value->status) {
              $entities_reference_published = true;
              break;
            }
          }
        }
        //Si tous les spectacles du festival sont dépubliés, on sauvegarde le festival
        if(!$entities_reference_published){
          watchdog('domainedo_shows', 'Node show Re-publié - festival sauvegardé');
          $wrapper->save();
        }
      }


    }
    // Si Publication
    if ($node->original->status == 0 && $node->status == 1) {
      $festival = getFestival($node);

      if($festival) {
        $entities_reference_published = true;
        $wrapper = entity_metadata_wrapper('node', $festival);

        // teste si les spectacles référencés sont publiés
        if (isset($wrapper->{"field_festival"})) {
          $target_ids = $wrapper->{"field_festival"}->value();
          //dpm($target_ids);
          foreach($target_ids as $key => $value) {
            // Si tous les autes spectacles sont dépubliés
            if($value->status && $value != $node) {
              $entities_reference_published = true;
              break;
            }
          }
        }
        //Si tous les spectacles du festival sont dépubliés, on sauvegarde le festival
        if(!$entities_reference_published) {
          $wrapper->save();
          watchdog('domainedo_shows', 'Node show Re-publié - festival sauvegardé');
        }
      }
    }
  }
}

